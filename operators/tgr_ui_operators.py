import bpy


def layer_name_by_index(context, index: int) -> str:
    layers = context.active_object.tgr_layer_collection

    for layer in layers:
        if layer.index == index:
            return layer.ui_name

    return "NOT NAMED LAYER"


class TGR_OT_GenerateUI(bpy.types.Operator):
    """
    Generate the UI python script
    """

    bl_idname = "tgr.generate_ui"
    bl_label = "Generate UI"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        is_armature = context.active_object.type == 'ARMATURE'
        is_pose_mode = context.active_object.mode == 'POSE'
        is_edit_mode = context.active_object.mode == 'EDIT'
        return is_armature and (is_pose_mode or is_edit_mode)

    def execute(self, context):
        ui_props = context.object.tgr_ui_props
        try:
            text = bpy.data.texts["TGR_RigUI.py"]
            text.clear()
        except KeyError:
            text = bpy.data.texts.new("TGR_RigUI.py")

        text.write("# ----- Rig UI generated by TelergyRigger Addon -----\n"
                   "import bpy\n\n\n"
                   "class TGR_RIG_Properties(bpy.types.PropertyGroup):\n"
                   "\tpass\n\n\n")
        text.write("class TGR_RIG_PT_Layers_Panel(bpy.types.Panel):\n"
                   "\tbl_label = 'Bone Layers'\n"
                   "\tbl_idname = 'TGR_RIG_Layers_Panel'\n"
                   "\tbl_space_type = 'VIEW_3D'\n"
                   "\tbl_region_type = 'UI'\n"
                   f"\tbl_category = '{ui_props.panel_name}'\n\n"
                   "\tdef draw(self, context):\n"
                   "\t\tlayout = self.layout\n"
                   )
        ui_code = ui_props.ui_code.split("\n")
        for row in ui_code:
            text.write("\t\trow = layout.row(align=True)\n")
            cols = row.split(";")
            for col in cols:
                if col.isalpha():
                    text.write(f"\t\trow.label(text='{col}')\n")
                elif col.isdigit():
                    text.write(f"\t\trow.prop(context.active_object.data, \'layers\', index={int(col)}, toggle"
                               f"=True, text=\'{layer_name_by_index(context, int(col))}\')\n")

        text.write("\n\n")
        text.write("def register():\n"
                   "\tbpy.utils.register_class(TGR_RIG_Properties)\n"
                   "\tbpy.utils.register_class(TGR_RIG_PT_Layers_Panel)\n\n"
                   "\tbpy.types.Scene.rig_props = bpy.props.PointerProperty(type=TGR_RIG_Properties)\n")
        text.write("\n\n")
        text.write("def unregister():\n"
                   "\tdel bpy.types.Scene.rig_props\n\n"
                   "\tbpy.utils.unregister_class(TGR_RIG_Properties)\n"
                   "\tbpy.utils.unregister_class(TGR_RIG_PT_Layers_Panel)\n")
        text.write("\n\n")
        text.write("def relink_drivers():\n"
                   "\t'''Update dependencies of drivers'''\n"
                   "\tfor obj in bpy.data.objects:\n"
                   "\t\tif obj.animation_data:\n"
                   "\t\t\tfor driver in obj.animation_data.drivers:\n"
                   "\t\t\t\tdriver.driver.expression = driver.driver.expression\n")
        text.write("\n\n")
        text.write("if __name__ == \"__main__\":\n"
                   "\tregister()\n"
                   "\trelink_drivers()\n")
        return {"FINISHED"}


class TGR_OT_RIG_UI_AddComponent(bpy.types.Operator):
    """
    Generate the UI python script
    """

    bl_idname = "tgr.ui_add_component"
    bl_label = "Add Layer"
    bl_options = {'REGISTER', 'UNDO'}

    component_type: bpy.props.EnumProperty(
        name="Type",
        items=[("LAYER", "LAYER", "Bone layer component"), ("LABEL", "LABEL", "Label component")],
    )

    value: bpy.props.StringProperty(
        name="Value",
        description="Describes the layer or label text",
        default=""
    )

    line: bpy.props.IntProperty(
        name="Line",
        description="Line in which the component will be placed",
        default=0,
        min=0
    )

    layer_name: bpy.props.StringProperty(
        name="Layer Name",
        description="Layer to get the information from",
        default=""
    )

    def __init__(self):
        tgr_components = bpy.context.active_object.tgr_ui_components
        components_line = [component.line for component in tgr_components]
        if len(components_line) == 0:
            self.line = 0
            # self.report({"WARNING"}, "Nothing here")
        else:
            self.line = max(components_line) + 1
            # self.report({"WARNING"}, f"Line value: {self.line}")

    @classmethod
    def poll(cls, context):
        is_armature = context.active_object.type == 'ARMATURE'
        is_pose_mode = context.active_object.mode == 'POSE'
        is_edit_mode = context.active_object.mode == 'EDIT'
        return is_armature and (is_pose_mode or is_edit_mode)

    def execute(self, context):
        components = context.active_object.tgr_ui_components
        components.add()
        components[-1].component_type = self.component_type
        components[-1].value = self.value
        components[-1].line = self.line
        print("New Layer Added")
        return {"FINISHED"}

    def invoke(self, context, event):
        wm = context.window_manager
        return wm.invoke_props_dialog(self)

    def draw(self, context):
        tgr_components = context.active_object.tgr_ui_components

        layout = self.layout
        row = layout.row()
        row.prop(self, "component_type")

        row = layout.row()
        row.prop(self, "value")

        if self.component_type == "LAYER":
            row = layout.row()
            row.label(text="Choose a layer:")

            row = layout.row()
            row.prop_search(self, "layer_name", context.active_object, "tgr_layer_collection")

        row = layout.row()
        row.prop(self, "line")


class TGR_OT_RIG_UI_AddNewLine(bpy.types.Operator):
    """
    Generate the UI python script
    """

    bl_idname = "tgr.ui_add_new_line"
    bl_label = "Add New Line"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        is_armature = context.active_object.type == 'ARMATURE'
        is_pose_mode = context.active_object.mode == 'POSE'
        is_edit_mode = context.active_object.mode == 'EDIT'
        return is_armature and (is_pose_mode or is_edit_mode)

    def execute(self, context):
        print("New Line Added")
        return {"FINISHED"}


class TGR_OT_RIG_UI_AddLabel(bpy.types.Operator):
    """
    Generate the UI python script
    """

    bl_idname = "tgr.ui_add_label"
    bl_label = "Add Label"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        is_armature = context.active_object.type == 'ARMATURE'
        is_pose_mode = context.active_object.mode == 'POSE'
        is_edit_mode = context.active_object.mode == 'EDIT'
        return is_armature and (is_pose_mode or is_edit_mode)

    def execute(self, context):
        print("New Label Added")
        return {"FINISHED"}


class TGR_OT_RIG_UI_ModifyItem(bpy.types.Operator):
    """
    Generate the UI python script
    """

    bl_idname = "tgr.ui_modify_item"
    bl_label = "Modify Item"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        is_armature = context.active_object.type == 'ARMATURE'
        is_pose_mode = context.active_object.mode == 'POSE'
        is_edit_mode = context.active_object.mode == 'EDIT'
        return is_armature and (is_pose_mode or is_edit_mode)

    def execute(self, context):
        print("Item Modified")
        return {"FINISHED"}


class TGR_OT_RIG_UI_Clear(bpy.types.Operator):
    """
    Generate the UI python script
    """

    bl_idname = "tgr.ui_clear"
    bl_label = "Clear"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        is_armature = context.active_object.type == 'ARMATURE'
        is_pose_mode = context.active_object.mode == 'POSE'
        is_edit_mode = context.active_object.mode == 'EDIT'
        return is_armature and (is_pose_mode or is_edit_mode)

    def execute(self, context):
        components = context.active_object.tgr_ui_components
        components.clear()
        self.report({"INFO"}, "RIG UI Cleared!")
        return {"FINISHED"}


class TGR_OT_RIG_UI_RemoveItem(bpy.types.Operator):
    """
    Generate the UI python script
    """

    bl_idname = "tgr.ui_remove_item"
    bl_label = "Remove Item"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        is_armature = context.active_object.type == 'ARMATURE'
        is_pose_mode = context.active_object.mode == 'POSE'
        is_edit_mode = context.active_object.mode == 'EDIT'
        # TODO: Add condition of at least one item selected
        return is_armature and (is_pose_mode or is_edit_mode)

    def execute(self, context):
        components = context.active_object.tgr_ui_components
        while any(filter(lambda x: x.selected, components)):
            for i, component in enumerate(components):
                if component.selected:
                    components.remove(i)
                    break
        return {"FINISHED"}
